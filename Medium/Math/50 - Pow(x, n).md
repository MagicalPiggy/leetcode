# 题目描述

实现 pow(x, n) ，即计算 x 的 n 次幂函数。

```java
示例 1:

输入: 2.00000, 10
输出: 1024.00000
示例 2:

输入: 2.10000, 3
输出: 9.26100
示例 3:

输入: 2.00000, -2
输出: 0.25000
解释: 2-2 = 1/22 = 1/4 = 0.25

说明:
-100.0 < x < 100.0
n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 
```

# 思路：快速幂（递归）
最普通的想法就是对x做n次乘法，但还有更快的方法就是快速幂。
快速幂用到了分治思想，可以快速降低问题的规模。
如果我们要计算2^64^，可以按照如下顺序进行：

<font color=red>2→2^2^→2^4^→2^8^→2^16^→2^32^→2^64^  </font>

可见只需要进行6次而不是64次，极大提高了计算速度。

再举一个例子，如果我们要计算2^77^ ，我们可以按照以下顺序进行：

<font color=red>x → x^2^ →x^4^ →x^9^  →x^19^ → x^38^  → x^77^  </font>

上面步骤中，部分结果进行平方后，还要额外乘一个 x。

判断何时需要多乘，可以从右往左推。


当我们要计算 x^n^ 时，我们可以先递归地计算出 y = x^⌊n/2⌋^ ，其中 ⌊n/2⌋表示进行下取整；

根据y的结果来求x^n^，如果 x^n^中的n 为偶数，那么 **x^n^= y^2^** ；
如果 n 为奇数，那么 **x^n^**= **y^2^**  * x；

递归的边界为 n = 0(任意数的 0 次方均为 1)。
由于每次递归都会使得指数减少一半，因此时间复杂度为 O(log n)，算法可以在很快的时间内得到结果。

此外，当指数为负数时，可以取倒数得到结果。

## 代码：

```java
    public double myPow(double x, int n) {
        long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }

    public double quickMul(double x, long N) {
        if (N == 0) {
            return 1.0;
        }
        double y = quickMul(x, N / 2);
        return N % 2 == 0 ? y * y : y * y * x;
    }
```

时间复杂度 O(log n)
空间复杂度 O(log n)

