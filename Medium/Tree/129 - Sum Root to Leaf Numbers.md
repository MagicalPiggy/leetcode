# 题目描述
给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。

例如，从根到叶子节点路径 1->2->3 代表数字 123。

计算从根到叶子节点生成的所有数字之和。

说明: 叶子节点是指没有子节点的节点。
示例 1:

输入: [1,2,3]

```java
    1
   / \
  2   3
```

输出: 25
解释:
从根到叶子节点路径 1->2 代表数字 12.
从根到叶子节点路径 1->3 代表数字 13.
因此，数字总和 = 12 + 13 = 25.

示例 2:

输入: [4,9,0,5,1]

```java
    4
   / \
  9   0
 / \
5   1
```

输出: 1026
解释:
从根到叶子节点路径 4->9->5 代表数字 495.
从根到叶子节点路径 4->9->1 代表数字 491.
从根到叶子节点路径 4->0 代表数字 40.
因此，数字总和 = 495 + 491 + 40 = 1026.

# 思路
普通先序遍历即可，每到一个节点更新一次当前数字（旧值*10+新值），这个数字作为参数传入下一层递归中，由于不是引用变量，所以返回上层时不需要进行回退。每当到达叶子节点时，当前数字加到结果中。

## 代码

```java
class Solution {
	int temp = 0;
    public int sumNumbers(TreeNode root) {
    	if (root == null) return 0;
    	dfs(root, 0);
    	return sum;
    }

    private void dfs(TreeNode root, int temp) {
    	if (root == null) return ;
    	temp = temp * 10 + root.val;
    	if (root.left == root.right) sum += temp;
    	dfs(root.left, temp);
    	dfs(root.right, temp);
    }
}

```
执行用时：
0 ms, 在所有 Java 提交中击败了100.00%的用户
内存消耗：37.5 MB, 在所有 Java 提交中击败了5.55%的用户