# 题目描述
难度：中等
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

```java
示例 1:
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

# 思路：滑动窗口（双指针）
这道题主要用到思路是：滑动窗口

其实就是一个队列,比如例题中的 abcabcbb，进入这个队列（窗口）为 abc 满足题目要求，当再进入 a，队列变成了 abca，这时候不满足要求。所以，我们要移动这个队列，把队列的左边的元素移出，直到满足题目要求。

<font color=red>判断是否满足要求，使用的是HashMap<字符，字符下标>；“窗口”使用左右指针表示。循环过程中i（右指针）不断右移，当检测到重复字符时，将左指针也右移，从而实现滑动窗口的效果，保证窗口中的子串始终不存在重复的字符。

- 首先，判断当前字符是否包含在map中，如果不包含，将该字符添加到map（字符，字符在数组下标）,
             此时没有出现重复的字符，左指针不需要变化。此时不重复子串的长度为：i-left+1，与原来的maxLen比较，取最大值；
         
- 如果当前字符 ch 包含在 map中，此时有2类情况：
1. 如：**"abca**"，当遍历到第二个a前，当前有效子段是 "abc"，又往右遍历到a，那么此时左指针移动，更新 left 为 map.get(a)+1=1，当前有效子段更新为"bca"；
   
2. 如：**"abba"**，先添加a,b进map，此时left=0，再添加b，发现map中包含b，就是1）的情况，于是左指针右移，更新 left=map.get(b)+1=2，此时子段更新为"b"，但要注意，虽然窗口中不包含a，但是map中仍然有<a，0>的记录。随后，i右移遍历到a，发现a包含在map中，但此时不能像1）一样处理，因为此时左指针不需要再移动！显然，"ba"中的a并没有重复，如果还按照map中的值来判断，就会出现“假重复”。
       
- 于是，为了对以上两种情况统一处理，判断左指针何时该移动，采用**left = Math.max(left , map.get(s.charAt(i))+1)**，避免了“假重复”的出现。

注意，为了判断重复的准确，每次访问一个字符后，都要更新字符的位置！
             
时间复杂度：O(n)

## 代码

```java
public int lengthOfLongestSubstring(String s) {
        HashMap<Character, Integer> map = new HashMap<>();
        // 用于记录最大不重复子串的长度
        int maxLen = 0;
        // 滑动窗口左指针
        int left = 0;
        for (int i = 0; i < s.length() ; i++) {
            if(map.containsKey(s.charAt(i))) {
                left = Math.max(left , map.get(s.charAt(i)) + 1);
            }
            // 不管是否更新left，都要更新 s.charAt(i) 的位置
            map.put(s.charAt(i) , i);
            // 更新最大长度
            maxLen = Math.max(maxLen , i - left + 1);
        }
        
        return maxLen;
    }
```